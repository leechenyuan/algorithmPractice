##这道题做得好有成就感!!!哈哈哈,一次通过

### 假设相交的节点为Connect
#曾经的思路
. 首先，由于O(1)的内存限制，我们就没办法使用hashMap来存储所有的引用地址(hashCode方法如果没有被改的话可以用)
. 然后，我不知道怎么想到，反正就是想了一阵子，然后突然悟道:
    > 我可以把两个链表翻转过来啊！如果他们有相同的元素的话，就一直向前做，到了某个元素不相同的时候，返回上一个元素(上一个相同)不就得了?
    > 因为不破坏连接原来的结构，所有找到原来的元素以后，我反转回去不久得了?
    > 然后，我就开始按着想法做了。 后来，写完了测试以后，发现不对。检查一下，发现自己错了。 因为，如果两个链表连接一起的话，翻转了其实得到的是另外2个相连的链表
    > 问题不但回到了原点，而且还把结构弄坏了。
    > 结论就是此路不通。自己觉得陷入了死局。
. 后来，我也不知道怎么办了，就胡乱想，我想想这链表是两条路。不知道怎么搞得，我突然联想到把A的结尾和B的头部连接起来，这就是一个个棒棒糖的形状了！！！激动!感觉找到了光。
    > 如果2个链表有共同的节点，假设A链表的长度为 a + x ,B 链表的长度为 b + x . 如果有换的话，这个棒棒糖就会陷入死循环，那边遍历它的长度的时候就会大于A+B的长度!
    > 终于知道怎么判断是否有环了！ 先算出A、B的长度， 然后将A的结尾和B的头连接起来，然后算这个帮帮糖的长度，如果没有共同的节点，那么长度就是 A+B ,一旦大于A+B,说明进入死循环，有环。
. 知道有环了以后，怎么判断哪个节点是第一个连在一起的节点呢? 本来以为 (A-B)/2 得出了x的长度，那么 A - x = a ,只要遍历A链表的前a个元素，然后返回下一个就好了。可惜还是太年轻，又错了
. 知道有环，(A-B)/2 = ( (a+x)-(b+x) ) / 2 ;根本得不到x的长度。  也就无从算出哪个节点是了。。。好郁闷。
. a + x = A ; b + x = B ；A和B都是可以算出，是已知条件，但是3个未知数必须要3个恒等式才能够解出来。也就无法算出x了，算不出x就无法知道那个节点是要返回的了
. A - B = a + x - ( b+x) = a - b ;根本没意思嘛，相当于什么信息都不知道，算了，睡觉吧，很晚了.
. 就在准备睡觉的时候，突然想到，a - b 如果>0，说明A链表比较长。如果 A - B < 0 说明A比B 短， 只要从A、B链表距离 Connect节点相同的位置开始相互比较，2者的引用相同，不久说明是第一个相同节点了吗?!!!,对了，就是这样！
. 本来觉得，算不出x就解不出。没想到 a-b看是无用的值竟然是结题的钥匙! 真的是，数据没有不起眼的，如果不起眼，有时候真的是自己挖掘能力太弱啊。
